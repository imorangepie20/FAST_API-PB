# LLM 자연어 검색 구현 기술 문서

> 작성일: 2026-02-08
> 프로젝트: 음악 추천 시스템 - LLM 기반 자연어 검색

---

## 1. 개요

### 1.1 목표
사용자가 자연어로 음악을 검색할 수 있는 기능 구현
- 예: "비오는 날 카페에서 들을 잔잔한 재즈"
- 예: "우울할 때 듣는 감성 발라드"
- 예: "신나는 운동 음악"

### 1.2 구현된 기능
| 기능 | 설명 | 계획서 항목 |
|------|------|------------|
| 자연어 검색 | 한국어 쿼리로 음악 검색 | 2번 |
| RAG 설명 생성 | 검색 결과에 대한 추천 이유 설명 | 3번 |
| 감성 기반 필터링 | 감정 표현 → 오디오 특성 필터 | 4번 (통합) |

---

## 2. 시스템 아키텍처

### 2.1 전체 흐름도

```
┌─────────────────────────────────────────────────────────────────────┐
│  사용자 입력: "우울할 때 듣는 잔잔한 음악"                            │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1단계: LLM 쿼리 분석 (Gemini 1회 호출)                              │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  입력: "우울할 때 듣는 잔잔한 음악"                             │ │
│  │  출력:                                                        │ │
│  │  {                                                            │ │
│  │    "english_query": "calm melancholic sad mellow music",      │ │
│  │    "detected_emotion": "sad",                                 │ │
│  │    "audio_filters": {                                         │ │
│  │      "energy_max": 0.4,                                       │ │
│  │      "valence_max": 0.4                                       │ │
│  │    }                                                          │ │
│  │  }                                                            │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2단계: 벡터 검색 (ChromaDB)                                        │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  쿼리: "calm melancholic sad mellow music" (영어)              │ │
│  │  필터: energy <= 0.4, valence <= 0.4                          │ │
│  │  모델: all-MiniLM-L6-v2 (영어 전용, 고성능)                    │ │
│  │  결과: 유사도 높은 곡 5개                                      │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3단계: LLM 설명 생성 (Gemini 2회 호출)                              │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  입력: 검색된 5곡 + 원본 한국어 쿼리                           │ │
│  │  출력: 각 곡에 대한 맞춤 추천 이유 (한국어)                     │ │
│  │  예: "잔잔한 멜로디와 차분한 분위기가 우울한 날의 감성을..."     │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│  최종 응답                                                          │
│  - tracks: 검색된 곡 목록 (5곡)                                     │
│  - explanation: 각 곡별 추천 이유                                   │
│  - analyzed_query: 영어로 번역된 쿼리 (디버그용)                     │
│  - detected_emotion: 감지된 감정                                    │
│  - applied_filters: 적용된 오디오 필터                               │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 파일 구조

```
fastapi/
├── app/
│   ├── routers/
│   │   └── llm.py                 # API 엔드포인트
│   └── services/
│       └── llm/
│           ├── __init__.py
│           ├── config.py          # Gemini API 설정
│           ├── query_analyzer.py  # 쿼리 분석 (번역 + 감성)
│           ├── vector_search.py   # ChromaDB 벡터 검색
│           └── explainer.py       # 추천 이유 생성
├── scripts/
│   └── init_vector_db.py          # 벡터 DB 초기화 스크립트
└── data/
    ├── spotify_114k_with_tags.csv # 원본 데이터
    └── chroma_db/                 # ChromaDB 저장소
```

---

## 3. 기술적 결정 및 근거

### 3.1 임베딩 모델 선택

#### 문제 상황
처음에 한국어 쿼리를 영어 임베딩 모델(`all-MiniLM-L6-v2`)로 직접 검색했을 때:

```
쿼리: "비오는 날 카페에서 들을 잔잔한 재즈"
기대: jazz 장르
결과: ambient, club (유사도 0.29~0.33) ❌
```

#### 시도한 방법들

| 방법 | 장점 | 단점 | 선택 |
|------|------|------|------|
| **1단계: 다국어 모델** | 추가 API 호출 없음 | DB 재초기화 70분, 정확도 중간 | ❌ |
| **2단계: LLM 번역 + 감성 분석** | DB 재사용, 4번 기능 통합, 높은 정확도 | API 호출 1회 추가 | ✅ |

#### 최종 결정: 2단계 방식
```
이유:
1. 기존 DB 재사용 (70분 절약)
2. 영어 전용 모델이 다국어 모델보다 정확도 높음
3. 감성 분석(4번 기능)도 같이 구현 (1석 2조)
4. Gemini 무료 티어 1,500회/일 내에서 충분
```

### 3.2 오디오 특성 필터 근거

#### Spotify Audio Features 공식 정의

| 특성 | 정의 | 범위 |
|------|------|------|
| **energy** | 강도와 활동성의 지각적 측정. 빠르고, 시끄럽고, 노이즈가 많은 트랙은 에너지가 높음 | 0.0 (조용) ~ 1.0 (강렬) |
| **valence** | 트랙이 전달하는 음악적 긍정성. 높으면 행복/밝음, 낮으면 슬픔/우울 | 0.0 (슬픔) ~ 1.0 (행복) |
| **acousticness** | 트랙이 어쿠스틱인지에 대한 신뢰도 측정 | 0.0 ~ 1.0 |
| **danceability** | 템포, 리듬 안정성, 비트 강도 등을 기반으로 춤추기 적합한 정도 | 0.0 ~ 1.0 |

#### 감정 → 오디오 특성 매핑 가이드라인

```python
# 프롬프트에 포함된 가이드라인
"우울할 때 듣는 잔잔한 음악" → energy_max: 0.4, valence_max: 0.4
"운동할 때 신나는 음악"      → energy_min: 0.7, valence_min: 0.6
"카페에서 일할 때"          → energy: 0.3~0.6 (중간)
"비오는 날 재즈"            → 필터 없음, 번역만
```

**근거**: Spotify가 114k 데이터셋의 모든 곡에 대해 이미 이 수치를 분석해두었음. LLM은 자연어를 이해하고, 이 수치 범위로 변환하는 역할만 수행.

---

## 4. 프롬프트 설계

### 4.1 쿼리 분석 프롬프트 (query_analyzer.py)

```python
QUERY_ANALYSIS_PROMPT = """You are a music search query analyzer.
Analyze the user's query and return a JSON response.

User Query: {query}

Tasks:
1. Translate the query to English music search terms (genres, moods, styles, activities)
2. Analyze the emotional tone and suggest audio feature ranges (0.0 to 1.0)

Return ONLY valid JSON in this exact format:
{
    "english_query": "translated search terms for music tags",
    "detected_emotion": "emotion name or null",
    "audio_filters": {
        "energy_min": null or 0.0-1.0,
        "energy_max": null or 0.0-1.0,
        "valence_min": null or 0.0-1.0,
        "valence_max": null or 0.0-1.0
    }
}

Audio feature guidelines:
- energy: 0.0 = calm/quiet, 1.0 = energetic/loud
- valence: 0.0 = sad/melancholic, 1.0 = happy/cheerful

Examples:
- "우울할 때 듣는 잔잔한 음악" → energy_max: 0.4, valence_max: 0.4
- "운동할 때 신나는 음악" → energy_min: 0.7, valence_min: 0.6

Only set audio filters when the query clearly implies an emotional state.
If the query is just about genre/artist style, leave audio_filters as null."""
```

#### 프롬프트 설계 원칙
1. **명확한 출력 형식**: JSON 스키마를 정확히 지정
2. **가이드라인 제공**: 감정 → 수치 변환 기준 명시
3. **예시 포함**: 구체적인 입출력 예시로 일관성 확보
4. **선택적 필터**: 감정이 명확하지 않으면 null 반환

### 4.2 설명 생성 프롬프트 (explainer.py)

```python
CONTEXTUAL_PROMPT = """사용자가 "{search_context}" 를 검색했습니다.

아래 곡들이 왜 이 검색에 적합한지 각각 1-2문장으로 설명해주세요.
검색 의도와 연결하여 설명하세요.

곡 목록:
{tracks_info}

JSON 형식으로 응답:
{{"explanations": ["곡1 설명", "곡2 설명", ...]}}"""
```

#### 설계 의도
- **검색 맥락 반영**: 원본 한국어 쿼리를 그대로 사용
- **간결한 설명**: 1-2문장으로 제한 (UI 고려)
- **연결성 강조**: "이 검색에 왜 적합한지" 초점

---

## 5. 트러블슈팅

### 5.1 중복 track_id 문제

#### 증상
```
Error: Expected IDs to be unique, found duplicates of: 5A6E9cVlxYAmEvdbEE4w9Y...
```

#### 원인
`spotify_114k_with_tags.csv`에 동일한 `track_id`가 여러 번 존재

#### 해결
```python
# init_vector_db.py에 추가
original_count = len(df)
df = df.drop_duplicates(subset=["track_id"], keep="first")
duplicate_count = original_count - len(df)
if duplicate_count > 0:
    logger.warning(f"중복 track_id {duplicate_count:,}개 제거됨 → {len(df):,}곡")
```

#### 결과
- 114,000곡 → 89,741곡 (24,259개 중복 제거)

---

### 5.2 한국어 쿼리 검색 정확도 문제

#### 증상
```
쿼리: "비오는 날 카페에서 들을 잔잔한 재즈"
기대: jazz 장르
결과: ambient, club (유사도 0.29) ❌
```

#### 원인
- 임베딩 모델(`all-MiniLM-L6-v2`)이 영어 전용
- 한국어 쿼리와 영어 태그 간 의미 매칭 실패

#### 시도한 해결책

**1단계: 다국어 모델 (`paraphrase-multilingual-MiniLM-L12-v2`)**
```python
# vector_search.py 수정
EMBEDDING_MODEL = "sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"
```
- 문제: DB 재초기화 필요 (70분), 성능이 영어 전용보다 낮음

**2단계: LLM 번역 + 영어 모델 유지 (최종 선택)**
```python
# query_analyzer.py 추가
# LLM이 한국어 → 영어 번역 + 감성 분석
query_analysis = await analyze_query(request.query)
search_query = query_analysis["english_query"]  # 영어로 검색
```

#### 최종 결과
- 기존 DB 재사용 (70분 절약)
- 감성 분석(4번 기능) 동시 구현
- 예상 유사도: 0.5+ (개선)

---

### 5.3 벡터 DB 비어있음 문제

#### 증상
```json
{
  "success": false,
  "error": "벡터 검색 서비스가 준비되지 않았습니다.",
  "collection_size": 0
}
```

#### 원인
- `--clear` 옵션으로 DB 초기화 시작 후 중단
- 기존 데이터가 삭제되고 새 데이터가 추가되지 않음

#### 해결
```powershell
python scripts/init_vector_db.py
# --clear 없이 실행하면 기존 데이터 위에 추가
# 약 70분 소요
```

---

### 5.4 Protobuf 버전 충돌 경고

#### 증상
```
AttributeError: 'MessageFactory' object has no attribute 'GetPrototype'
```

#### 원인
- TensorFlow와 ChromaDB의 protobuf 버전 충돌

#### 해결
- **무시 가능**: 경고일 뿐, 기능에 영향 없음
- **완전 해결 (선택)**: `pip install protobuf==4.25.3`

---

### 5.5 임베딩 함수 충돌 오류

#### 증상
```
Error: An embedding function already exists in the collection configuration,
new: sentence_transformer vs persisted: default
```

#### 원인
- 다른 경로(`D:\lecture\colab\chroma_store`)에 기존 ChromaDB 데이터 존재
- 기존 데이터는 `default` 임베딩 함수로 생성됨
- 새로 초기화할 때 `sentence_transformer` 임베딩 함수 사용

#### 해결
1. 파일 탐색기에서 "chroma" 검색
2. 기존 `chroma_store` 폴더 삭제
3. `python scripts/init_vector_db.py` 재실행

---

### 5.6 환경변수 이름 불일치 (GOOGLE_API_KEY vs GEMINI_API_KEY)

#### 증상
```
2026-02-08 21:20:15 - WARNING - GEMINI_API_KEY가 설정되지 않았습니다.
2026-02-08 21:20:15 - WARNING - QueryAnalyzer가 준비되지 않아 원본 쿼리 사용
```
- 설명 생성(explainer.py)은 동작하지만, 쿼리 분석(query_analyzer.py)은 실패
- `analyzed_query`가 영어 번역 없이 원본 한국어 그대로 반환됨

#### 원인
| 파일 | 사용하던 환경변수 |
|------|------------------|
| `config.py` | `GOOGLE_API_KEY` ✅ |
| `query_analyzer.py` | `GEMINI_API_KEY` ❌ (불일치) |

`explainer.py`는 `config.py`를 import하여 `GOOGLE_API_KEY` 사용
`query_analyzer.py`는 직접 `os.getenv("GEMINI_API_KEY")` 호출 → 환경변수 없음

#### 해결
```python
# query_analyzer.py 수정
# 변경 전
import os
api_key = os.getenv("GEMINI_API_KEY")

# 변경 후
from .config import get_llm_config
config = get_llm_config()
api_key = config.GOOGLE_API_KEY
```

#### 교훈
- 환경변수는 한 곳(config.py)에서 관리하고 다른 모듈에서 import
- 같은 API 키를 여러 이름으로 사용하지 않기 (`GOOGLE_API_KEY` vs `GEMINI_API_KEY`)

---

## 6. API 명세

### 6.1 자연어 검색

```
POST /api/llm/search
```

#### Request Body
```json
{
  "query": "비오는 날 카페에서 들을 잔잔한 재즈",
  "page": 1,
  "include_explanation": true,
  "genres": null,
  "energy_min": null,
  "energy_max": null,
  "valence_min": null,
  "valence_max": null
}
```

#### Response
```json
{
  "success": true,
  "query": "비오는 날 카페에서 들을 잔잔한 재즈",
  "tracks": [
    {
      "track_id": "abc123",
      "artist": "Bill Evans",
      "title": "Waltz for Debby",
      "genre": "jazz",
      "tags": "jazz, piano, mellow, classic",
      "similarity_score": 0.65,
      "explanation": "잔잔한 피아노 선율이 비오는 날 카페의 분위기와 잘 어울립니다."
    }
  ],
  "total": 5,
  "page": 1,
  "max_page": 3,
  "has_more": true,
  "collection_size": 81765,
  "analyzed_query": "rainy day cafe jazz mellow calm",
  "detected_emotion": "relaxed",
  "applied_filters": {
    "energy_max": 0.5
  }
}
```

### 6.2 검색 도움말

```
GET /api/llm/search/help
```

#### Response
```json
{
  "placeholders": [
    "신나는 운동 음악",
    "비오는 날 카페에서 들을 잔잔한 음악",
    "새벽에 혼자 듣는 감성 발라드"
  ],
  "help": {
    "기분/감정": ["우울할 때", "신날 때", "설렐 때"],
    "상황/장소": ["카페에서", "운동할 때", "출근길에"],
    "분위기": ["잔잔한", "신나는", "몽환적인"]
  }
}
```

### 6.3 서비스 상태

```
GET /api/llm/search/status
```

#### Response
```json
{
  "ready": true,
  "collection_size": 81765,
  "embedding_model": "sentence-transformers/all-MiniLM-L6-v2",
  "db_type": "ChromaDB"
}
```

---

## 7. 사용된 기술 스택

| 기술 | 용도 | 버전/모델 |
|------|------|----------|
| **ChromaDB** | 벡터 데이터베이스 | - |
| **Sentence-Transformers** | 텍스트 임베딩 | all-MiniLM-L6-v2 |
| **Google Gemini** | LLM (번역, 감성 분석, 설명 생성) | gemini-2.0-flash |
| **FastAPI** | REST API 서버 | - |
| **Spotify Audio Features** | 오디오 특성 데이터 | energy, valence, acousticness |

---

## 8. 제한 사항 및 주의 사항

### 8.1 API 호출 제한
- Gemini 무료 티어: 1,500 요청/일
- 검색 1회당 LLM 호출: 2회 (분석 1회 + 설명 1회)
- 일일 최대 검색: 약 750회

### 8.2 초기화 시간
- 벡터 DB 초기화: 약 70분 (89,741곡)
- 서버 시작: 약 30초 (모델 로딩)

### 8.3 임베딩 데이터
- 임베딩 대상: `{genre}, {tags}` (장르 + 아티스트 태그)
- 메타데이터: artist, title, audio_features (검색에 사용 안 함)

---

## 9. 향후 개선 사항

1. **캐싱**: 자주 사용되는 쿼리 결과 캐싱
2. **배치 처리**: 여러 쿼리 동시 처리
3. **오디오 특성 필터 UI**: 프론트엔드에서 슬라이더로 조절
4. **피드백 학습**: 사용자 피드백 기반 검색 품질 개선

---

## 10. 참고 자료

- [Spotify Audio Features Documentation](https://developer.spotify.com/documentation/web-api/reference/get-audio-features)
- [ChromaDB Documentation](https://docs.trychroma.com/)
- [Sentence-Transformers Models](https://www.sbert.net/docs/pretrained_models.html)
- [Google Gemini API](https://ai.google.dev/gemini-api/docs)
